
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ibmcloudprovider: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/IBM/ibm-csi-common/pkg/ibmcloudprovider/fake_volume_provider.go (92.0%)</option>
				
				<option value="file1">github.com/IBM/ibm-csi-common/pkg/ibmcloudprovider/volume_provider.go (67.3%)</option>
				
				<option value="file2">github.com/IBM/ibm-csi-common/pkg/messages/messages.go (100.0%)</option>
				
				<option value="file3">github.com/IBM/ibm-csi-common/pkg/messages/messages_en.go (100.0%)</option>
				
				<option value="file4">github.com/IBM/ibm-csi-common/pkg/metadata/fake_node_metadata.go (46.0%)</option>
				
				<option value="file5">github.com/IBM/ibm-csi-common/pkg/metadata/metadata.go (35.3%)</option>
				
				<option value="file6">github.com/IBM/ibm-csi-common/pkg/metrics/metrics.go (100.0%)</option>
				
				<option value="file7">github.com/IBM/ibm-csi-common/pkg/mountmanager/fake-safe-mounter.go (100.0%)</option>
				
				<option value="file8">github.com/IBM/ibm-csi-common/pkg/mountmanager/safe-mounter.go (100.0%)</option>
				
				<option value="file9">github.com/IBM/ibm-csi-common/pkg/utils/get_key.go (0.0%)</option>
				
				<option value="file10">github.com/IBM/ibm-csi-common/pkg/utils/lock_store.go (100.0%)</option>
				
				<option value="file11">github.com/IBM/ibm-csi-common/pkg/utils/logger.go (89.5%)</option>
				
				<option value="file12">github.com/IBM/ibm-csi-common/pkg/utils/utils.go (52.0%)</option>
				
				<option value="file13">github.com/IBM/ibm-csi-common/pkg/watcher/pv_watcher.go (51.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package ibmcloudprovider

import (
        "bytes"
        "testing"

        "github.com/IBM/ibmcloud-volume-interface/config"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider/fake"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
        provider_util "github.com/IBM/ibmcloud-volume-vpc/block/utils"
        vpcconfig "github.com/IBM/ibmcloud-volume-vpc/block/vpcconfig"
        "github.com/IBM/ibm-csi-common/pkg/utils"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "golang.org/x/net/context"
)

const (
        // TestProviderAccountID ...
        TestProviderAccountID = "test-provider-account"

        // TestProviderAccessToken ...
        TestProviderAccessToken = "test-provider-access-token"

        // TestIKSAccountID ...
        TestIKSAccountID = "test-iks-account"

        // TestZone ...
        TestZone = "test-zone"

        // IAMURL ...
        IAMURL = "test-iam-url"

        // IAMClientID ...
        IAMClientID = "test-iam_client_id"

        // IAMClientSecret ...
        IAMClientSecret = "test-iam_client_secret"

        // IAMAPIKey ...
        IAMAPIKey = "test-iam_api_key"

        // RefreshToken ...
        RefreshToken = "test-refresh_token"

        // TestEndpointURL ...
        TestEndpointURL = "http://some_endpoint"

        // TestAPIVersion ...
        TestAPIVersion = "2019-07-02"
)

// GetTestLogger ...
func GetTestLogger(t *testing.T) (logger *zap.Logger, teardown func()) <span class="cov10" title="4">{

        atom := zap.NewAtomicLevel()
        atom.SetLevel(zap.DebugLevel)

        encoderCfg := zap.NewProductionEncoderConfig()
        encoderCfg.TimeKey = "timestamp"
        encoderCfg.EncodeTime = zapcore.ISO8601TimeEncoder

        buf := &amp;bytes.Buffer{}

        logger = zap.New(
                zapcore.NewCore(
                        zapcore.NewJSONEncoder(encoderCfg),
                        zapcore.AddSync(buf),
                        atom,
                ),
                zap.AddCaller(),
        )

        teardown = func() </span><span class="cov10" title="4">{
                _ = logger.Sync()
                if t.Failed() </span><span class="cov0" title="0">{
                        t.Log(buf)
                }</span>
        }
        <span class="cov10" title="4">return</span>
}

// GetTestProvider ...
func GetTestProvider(t *testing.T, logger *zap.Logger) (*IBMCloudStorageProvider, error) <span class="cov1" title="1">{
        logger.Info("GetTestProvider-Getting New test Provider")
        // vpcBlockConfig struct
        vpcBlockConfig := &amp;vpcconfig.VPCBlockConfig{
                VPCConfig: &amp;config.VPCProviderConfig{
                        Enabled:              true,
                        VPCBlockProviderName: "vpc-classic",
                        EndpointURL:          TestEndpointURL,
                        VPCTimeout:           "30s",
                        MaxRetryAttempt:      5,
                        MaxRetryGap:          10,
                        APIVersion:           TestAPIVersion,
                        IamClientID:          IAMClientID,
                        IamClientSecret:      IAMClientSecret,
                },
                IKSConfig: &amp;config.IKSConfig{
                        Enabled:              true,
                        IKSBlockProviderName: "iks-block",
                },
                APIConfig: &amp;config.APIConfig{
                        PassthroughSecret: "",
                },
                ServerConfig: &amp;config.ServerConfig{
                        DebugTrace: true,
                },
        }
        // full config struct
        conf := &amp;config.Config{
                Server: &amp;config.ServerConfig{
                        DebugTrace: true,
                },
                Bluemix: &amp;config.BluemixConfig{
                        IamURL:          IAMURL,
                        IamClientID:     IAMClientID,
                        IamClientSecret: IAMClientSecret,
                        IamAPIKey:       IAMClientSecret,
                        RefreshToken:    RefreshToken,
                },
                VPC: &amp;config.VPCProviderConfig{
                        Enabled:              true,
                        VPCBlockProviderName: "vpc-classic",
                        EndpointURL:          TestEndpointURL,
                        VPCTimeout:           "30s",
                        MaxRetryAttempt:      5,
                        MaxRetryGap:          10,
                        APIVersion:           TestAPIVersion,
                },
                IKS: &amp;config.IKSConfig{
                        Enabled:              true,
                        IKSBlockProviderName: "iks-block",
                },
        }

        // Prepare provider registry
        registry, err := provider_util.InitProviders(vpcBlockConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error configuring providers", local.ZapError(err))
        }</span>

        <span class="cov1" title="1">cloudProvider := &amp;IBMCloudStorageProvider{
                ProviderName:   "vpc-classic",
                ProviderConfig: conf,
                Registry:       registry,
                ClusterInfo:    nil,
        }
        logger.Info("Successfully read provider configuration...")
        return cloudProvider, nil</span>
}

// FakeIBMCloudStorageProvider Provider
type FakeIBMCloudStorageProvider struct {
        ProviderName   string
        ProviderConfig *config.Config
        ClusterInfo    *utils.ClusterInfo
        fakeSession    *fake.FakeSession
}

var _ CloudProviderInterface = &amp;FakeIBMCloudStorageProvider{}

// NewFakeIBMCloudStorageProvider ...
func NewFakeIBMCloudStorageProvider(configPath string, logger *zap.Logger) (*FakeIBMCloudStorageProvider, error) <span class="cov1" title="1">{
        return &amp;FakeIBMCloudStorageProvider{ProviderName: "FakeIBMCloudStorageProvider",
                ProviderConfig: &amp;config.Config{VPC: &amp;config.VPCProviderConfig{VPCBlockProviderName: "VPCFakeProvider"}},
                ClusterInfo:    &amp;utils.ClusterInfo{}, fakeSession: &amp;fake.FakeSession{}}, nil
}</span>

// GetProviderSession ...
func (ficp *FakeIBMCloudStorageProvider) GetProviderSession(ctx context.Context, logger *zap.Logger) (provider.Session, error) <span class="cov1" title="1">{
        return ficp.fakeSession, nil
}</span>

// GetConfig ...
func (ficp *FakeIBMCloudStorageProvider) GetConfig() *config.Config <span class="cov1" title="1">{
        return ficp.ProviderConfig
}</span>

// GetClusterInfo ...
func (ficp *FakeIBMCloudStorageProvider) GetClusterInfo() *utils.ClusterInfo <span class="cov1" title="1">{
        return ficp.ClusterInfo
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package ibmcloudprovider

import (
        "fmt"
        "time"

        "github.com/IBM/ibmcloud-volume-interface/config"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
        provider_util "github.com/IBM/ibmcloud-volume-vpc/block/utils"
        vpcconfig "github.com/IBM/ibmcloud-volume-vpc/block/vpcconfig"
        "github.com/IBM/ibmcloud-volume-vpc/common/registry"
        "github.com/IBM/ibm-csi-common/pkg/utils"
        "go.uber.org/zap"
        "golang.org/x/net/context"
)

// IBMCloudStorageProvider Provider
type IBMCloudStorageProvider struct {
        ProviderName   string
        ProviderConfig *config.Config
        Registry       registry.Providers
        ClusterInfo    *utils.ClusterInfo
}

var _ CloudProviderInterface = &amp;IBMCloudStorageProvider{}

// NewIBMCloudStorageProvider ...
func NewIBMCloudStorageProvider(configPath string, logger *zap.Logger) (*IBMCloudStorageProvider, error) <span class="cov10" title="2">{
        logger.Info("NewIBMCloudStorageProvider-Reading provider configuration...")
        // Load config file
        conf, err := config.ReadConfig(configPath, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error loading configuration")
                return nil, err
        }</span>
        // Get only VPC_API_VERSION, in "2019-07-02T00:00:00.000Z" case vpc need only 2019-07-02"
        <span class="cov10" title="2">dateTime, err := time.Parse(time.RFC3339, conf.VPC.APIVersion)
        if err == nil </span><span class="cov0" title="0">{
                conf.VPC.APIVersion = fmt.Sprintf("%d-%02d-%02d", dateTime.Year(), dateTime.Month(), dateTime.Day())
        }</span> else<span class="cov10" title="2"> {
                logger.Warn("Failed to parse VPC_API_VERSION, setting default value")
                conf.VPC.APIVersion = "2020-07-02" // setting default values
        }</span>

        <span class="cov10" title="2">clusterInfo, err := utils.NewClusterInfo(logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Unable to load ClusterInfo", local.ZapError(err))
                return nil, err
        }</span>
        <span class="cov10" title="2">if conf.Bluemix.Encryption || conf.VPC.Encryption </span><span class="cov10" title="2">{
                // api Key if encryption is enabled
                apiKeyImp, err := utils.NewAPIKey(logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Unable to create API key getter", local.ZapError(err))
                        return nil, err
                }</span>
                <span class="cov10" title="2">err = apiKeyImp.UpdateIAMKeys(conf)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Unable to get API key", local.ZapError(err))
                        return nil, err
                }</span>
        }

        // Update the CSRF  Token
        <span class="cov10" title="2">if conf.Bluemix.PrivateAPIRoute != "" </span><span class="cov10" title="2">{
                conf.Bluemix.CSRFToken = string([]byte{}) // TODO~ Need to remove it
        }</span>

        <span class="cov10" title="2">if conf.API == nil </span><span class="cov0" title="0">{
                conf.API = &amp;config.APIConfig{
                        PassthroughSecret: string([]byte{}), // // TODO~ Need to remove it
                }
        }</span>
        <span class="cov10" title="2">vpcBlockConfig := &amp;vpcconfig.VPCBlockConfig{
                VPCConfig:    conf.VPC,
                IKSConfig:    conf.IKS,
                APIConfig:    conf.API,
                ServerConfig: conf.Server,
        }
        // Prepare provider registry
        registry, err := provider_util.InitProviders(vpcBlockConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error configuring providers", local.ZapError(err))
        }</span>

        <span class="cov10" title="2">var providerName string
        if isRunningInIKS() &amp;&amp; conf.IKS.Enabled </span><span class="cov0" title="0">{
                providerName = conf.IKS.IKSBlockProviderName
        }</span> else<span class="cov10" title="2"> if conf.VPC.Enabled </span><span class="cov10" title="2">{
                providerName = conf.VPC.VPCBlockProviderName
        }</span>

        <span class="cov10" title="2">cloudProvider := &amp;IBMCloudStorageProvider{
                ProviderName:   providerName,
                ProviderConfig: conf,
                Registry:       registry,
                ClusterInfo:    clusterInfo,
        }
        logger.Info("Successfully read provider configuration")
        return cloudProvider, nil</span>
}

func isRunningInIKS() bool <span class="cov10" title="2">{
        return true //TODO Check the master KUBE version
}</span>

// GetProviderSession ...
func (icp *IBMCloudStorageProvider) GetProviderSession(ctx context.Context, logger *zap.Logger) (provider.Session, error) <span class="cov1" title="1">{
        logger.Info("IBMCloudStorageProvider-GetProviderSession...")
        if icp.ProviderConfig.API == nil </span><span class="cov0" title="0">{
                icp.ProviderConfig.API = &amp;config.APIConfig{
                        PassthroughSecret: string([]byte{}), // // TODO~ Need to remove it
                }
        }</span>
        <span class="cov1" title="1">vpcBlockConfig := &amp;vpcconfig.VPCBlockConfig{
                VPCConfig:    icp.ProviderConfig.VPC,
                IKSConfig:    icp.ProviderConfig.IKS,
                APIConfig:    icp.ProviderConfig.API,
                ServerConfig: icp.ProviderConfig.Server,
        }
        session, isFatal, err := provider_util.OpenProviderSessionWithContext(ctx, vpcBlockConfig, icp.Registry, icp.ProviderName, logger)
        if err != nil || isFatal </span><span class="cov1" title="1">{
                logger.Error("Failed to get provider session", zap.Reflect("Error", err))
                return nil, err
        }</span>

        // Instantiate CloudProvider
        <span class="cov0" title="0">logger.Info("Successfully got the provider session", zap.Reflect("ProviderName", session.ProviderName()))
        return session, nil</span>
}

// GetConfig ...
func (icp *IBMCloudStorageProvider) GetConfig() *config.Config <span class="cov0" title="0">{
        return icp.ProviderConfig
}</span>

// GetClusterInfo ...
func (icp *IBMCloudStorageProvider) GetClusterInfo() *utils.ClusterInfo <span class="cov0" title="0">{
        return icp.ClusterInfo
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Bluemix Container Registry, 5737-D42
 * (C) Copyright IBM Corp. 2020 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets,  * irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package messages

import (
        "fmt"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// Message Wrapper Message/Error Class
type Message struct {
        Code         string
        Type         codes.Code
        RequestID    string
        Description  string
        BackendError string
        Action       string
}

// Error Implement the Error() interface method
func (msg Message) Error() string <span class="cov5" title="2">{
        return msg.Info()
}</span>

// Info ...
func (msg Message) Info() string <span class="cov10" title="4">{
        if msg.BackendError != "" </span><span class="cov5" title="2">{
                return fmt.Sprintf("{RequestID: %s, Code: %s, Description: %s, BackendError: %s, Action: %s}", msg.RequestID, msg.Code, msg.Description, msg.BackendError, msg.Action)
        }</span>
        <span class="cov5" title="2">return fmt.Sprintf("{RequestID: %s, Code: %s, Description: %s, Action: %s}", msg.RequestID, msg.Code, msg.Description, msg.Action)</span>
}

// MessagesEn ...
var MessagesEn map[string]Message

// GetCSIError ...
func GetCSIError(logger *zap.Logger, code string, requestID string, err error, args ...interface{}) error <span class="cov5" title="2">{
        userMsg := GetCSIMessage(code, args...)
        if err != nil </span><span class="cov1" title="1">{
                userMsg.BackendError = err.Error()
        }</span>
        <span class="cov5" title="2">userMsg.RequestID = requestID

        logger.Error("FAILED CSI ERROR", zap.Error(userMsg))
        return status.Error(userMsg.Type, userMsg.Info())</span>
}

// GetCSIMessage ...
func GetCSIMessage(code string, args ...interface{}) Message <span class="cov8" title="3">{
        userMsg := MessagesEn[code]
        if len(args) &gt; 0 </span><span class="cov1" title="1">{
                userMsg.Description = fmt.Sprintf(userMsg.Description, args...)
        }</span>
        <span class="cov8" title="3">return userMsg</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Bluemix Container Registry, 5737-D42
 * (C) Copyright IBM Corp. 2020 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets,  * irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package messages

import (
        "google.golang.org/grpc/codes"
)

// messagesEn ...
var messagesEn = map[string]Message{
        MethodUnimplemented: {
                Code:        MethodUnimplemented,
                Description: "'%s' CSI interface method not yet implemented",
                Type:        codes.Unimplemented,
                Action:      "Please do not use this method as its not implemented yet",
        },
        MissingVolumeName: {
                Code:        MissingVolumeName,
                Description: "Volume name not provided",
                Type:        codes.InvalidArgument,
                Action:      "Please provide volume name while creating volume",
        },
        NoVolumeCapabilities: {
                Code:        NoVolumeCapabilities,
                Description: "Volume capabilities must be provided",
                Type:        codes.InvalidArgument,
                Action:      "Please provide volume capabilities in the storage class before creating volume",
        },
        VolumeCapabilitiesNotSupported: {
                Code:        VolumeCapabilitiesNotSupported,
                Description: "Volume capabilities not supported",
                Type:        codes.InvalidArgument,
                Action:      "Please provide valid volume capabilities while creating volume",
        },
        InvalidParameters: {
                Code:        InvalidParameters,
                Description: "Failed to extract parameters",
                Type:        codes.InvalidArgument,
                Action:      "Please provide valid parameters",
        },
        ObjectNotFound: {
                Code:        ObjectNotFound,
                Description: "Object not found",
                Type:        codes.NotFound,
                Action:      "Please check 'BackendError' tag for more details",
        },
        InternalError: {
                Code:        InternalError,
                Description: "Internal error occurred",
                Type:        codes.Internal,
                Action:      "Please check 'BackendError' tag for more details",
        },
        VolumeAlreadyExists: {
                Code:        VolumeAlreadyExists,
                Description: "Volume with name '%s' already exists with same name and it is incompatible size '%s'",
                Type:        codes.AlreadyExists,
                Action:      "Please provide different name or have same size of existing volume",
        },
        VolumeInvalidArguments: {
                Code:        VolumeInvalidArguments,
                Description: "Invalid arguments for create volume",
                Type:        codes.InvalidArgument,
                Action:      "Please provide valid arguments while creating volume",
        },
        VolumeCreationFailed: {
                Code:        VolumeCreationFailed,
                Description: "Failed to create volume",
                Type:        codes.Internal,
                Action:      "Please check the error which return in BackendError tag",
        },
        EmptyVolumeID: {
                Code:        EmptyVolumeID,
                Description: "VolumeID must be provided",
                Type:        codes.InvalidArgument,
                Action:      "Please provide volume ID for attach/detach or delete it",
        },
        EmptyNodeID: {
                Code:        EmptyNodeID,
                Description: "NodeID is empty",
                Type:        codes.InvalidArgument,
                Action:      "Please check all node's labels by using kubectl command",
        },
        FailedPrecondition: {
                Code:        FailedPrecondition,
                Description: "Provider is not ready to responde",
                Type:        codes.FailedPrecondition,
                Action:      "Please retry after some time, if problem persist then report issue to IKS storage team",
        },
        NoStagingTargetPath: {
                Code:        NoStagingTargetPath,
                Description: "Staging target path not provided",
                Type:        codes.InvalidArgument,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
        NoTargetPath: {
                Code:        NoTargetPath,
                Description: "Target path must be provided",
                Type:        codes.InvalidArgument,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
        MountPointValidateError: {
                Code:        MountPointValidateError,
                Description: "Failed to check whether target path '%s' is a mount point",
                Type:        codes.FailedPrecondition,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
        UnmountFailed: {
                Code:        UnmountFailed,
                Description: "Unmount failed for '%s' target path",
                Type:        codes.Internal,
                Action:      "Please check if there is any error in POD describe related with volume detach",
        },
        MountFailed: {
                Code:        MountFailed,
                Description: "Failed to mount '%q' at '%q'",
                Type:        codes.Internal,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
        EmptyDevicePath: {
                Code:        EmptyDevicePath,
                Description: "Staging device path must be provided",
                Type:        codes.InvalidArgument,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
        DevicePathFindFailed: {
                Code:        DevicePathFindFailed,
                Description: "Failed to find '%s' device path",
                Type:        codes.Internal,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
        TargetPathCheckFailed: {
                Code:        TargetPathCheckFailed,
                Description: "Failed to check if staging target path '%s' exists",
                Type:        codes.Internal,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
        TargetPathCreateFailed: {
                Code:        TargetPathCreateFailed,
                Description: "Failed to create target path '%s'",
                Type:        codes.Internal,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
        VolumeMountCheckFailed: {
                Code:        VolumeMountCheckFailed,
                Description: "Failed to check if volume is already mounted on '%s'",
                Type:        codes.Internal,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
        FormatAndMountFailed: {
                Code:        FormatAndMountFailed,
                Description: "Failed to format '%s' and mount it at '%s'",
                Type:        codes.Internal,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
        NodeMetadataInitFailed: {
                Code:        NodeMetadataInitFailed,
                Description: "Failed to initialize node metadata",
                Type:        codes.NotFound, //i.e correct no need to change to other code
                Action:      "Please check the node labels as per BackendError, accordingly you may add the labels manually",
        },
        EmptyVolumePath: {
                Code:        EmptyVolumePath,
                Description: "Volume path can not be empty",
                Type:        codes.InvalidArgument,
                Action:      "Please check if volume is used by POD properly",
        },
        DevicePathNotExists: {
                Code:        DevicePathNotExists,
                Description: "Device path '%s' does not exist for volume ID '%s'",
                Type:        codes.NotFound,
                Action:      "Please check if volume is used by POD properly",
        },
        BlockDeviceCheckFailed: {
                Code:        BlockDeviceCheckFailed,
                Description: "Failed to determine if volume '%s' is block device or not",
                Type:        codes.Internal,
                Action:      "Please check if volume is used by POD properly",
        },
        GetDeviceInfoFailed: {
                Code:        GetDeviceInfoFailed,
                Description: "Failed to get device info",
                Type:        codes.Internal,
                Action:      "Please check if volume is used by POD properly",
        },
        GetFSInfoFailed: {
                Code:        GetFSInfoFailed,
                Description: "Failed to get FS info",
                Type:        codes.Internal,
                Action:      "Please check if volume is used by POD properly",
        },
        DriverNotConfigured: {
                Code:        DriverNotConfigured,
                Description: "Driver name not configured",
                Type:        codes.Unavailable,
                Action:      "Developer need to set the driver name",
        },
        RemoveMountTargetFailed: {
                Code:        RemoveMountTargetFailed,
                Description: "Failed to remove '%q' mount target",
                Type:        codes.Internal,
                Action:      "Please check if volume is used by POD properly",
        },
        CreateMountTargetFailed: {
                Code:        CreateMountTargetFailed,
                Description: "Failed to create '%q' mount target",
                Type:        codes.Internal,
                Action:      "Please check if volume is used by POD properly",
        },
        ListVolumesFailed: {
                Code:        ListVolumesFailed,
                Description: "Failed to list volumes",
                Type:        codes.Internal,
                Action:      "Please check 'BackendError' tag for more details",
        },
        StartVolumeIDNotFound: {
                Code:        StartVolumeIDNotFound,
                Description: "The volume ID '%s' specified in the start parameter of the list volume call could not be found",
                Type:        codes.Aborted,
                Action:      "Please verify that the start volume ID is correct and whether you have access to the volume ID",
        },
        FileSystemResizeFailed: {
                Code:        FileSystemResizeFailed,
                Description: "Failed to resize the file system",
                Type:        codes.Internal,
                Action:      "Please check if there is any error in PVC describe related with volume resize",
        },
        VolumePathNotMounted: {
                Code:        VolumePathNotMounted,
                Description: "VolumePath '%s' is not mounted",
                Type:        codes.FailedPrecondition,
                Action:      "Please check if there is any error in POD describe related with volume attach",
        },
}

// InitMessages ...
func InitMessages() map[string]Message <span class="cov8" title="1">{
        return messagesEn
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by counterfeiter. DO NOT EDIT.
package metadata

import (
        "sync"
)

type FakeNodeMetadata struct {
        GetRegionStub        func() string
        getRegionMutex       sync.RWMutex
        getRegionArgsForCall []struct {
        }
        getRegionReturns struct {
                result1 string
        }
        getRegionReturnsOnCall map[int]struct {
                result1 string
        }
        GetWorkerIDStub        func() string
        getWorkerIDMutex       sync.RWMutex
        getWorkerIDArgsForCall []struct {
        }
        getWorkerIDReturns struct {
                result1 string
        }
        getWorkerIDReturnsOnCall map[int]struct {
                result1 string
        }
        GetZoneStub        func() string
        getZoneMutex       sync.RWMutex
        getZoneArgsForCall []struct {
        }
        getZoneReturns struct {
                result1 string
        }
        getZoneReturnsOnCall map[int]struct {
                result1 string
        }
        invocations      map[string][][]interface{}
        invocationsMutex sync.RWMutex
}

func (fake *FakeNodeMetadata) GetRegion() string <span class="cov1" title="1">{
        fake.getRegionMutex.Lock()
        ret, specificReturn := fake.getRegionReturnsOnCall[len(fake.getRegionArgsForCall)]
        fake.getRegionArgsForCall = append(fake.getRegionArgsForCall, struct {
        }{})
        fake.recordInvocation("GetRegion", []interface{}{})
        fake.getRegionMutex.Unlock()
        if fake.GetRegionStub != nil </span><span class="cov0" title="0">{
                return fake.GetRegionStub()
        }</span>
        <span class="cov1" title="1">if specificReturn </span><span class="cov0" title="0">{
                return ret.result1
        }</span>
        <span class="cov1" title="1">fakeReturns := fake.getRegionReturns
        return fakeReturns.result1</span>
}

func (fake *FakeNodeMetadata) GetRegionCallCount() int <span class="cov0" title="0">{
        fake.getRegionMutex.RLock()
        defer fake.getRegionMutex.RUnlock()
        return len(fake.getRegionArgsForCall)
}</span>

func (fake *FakeNodeMetadata) GetRegionCalls(stub func() string) <span class="cov0" title="0">{
        fake.getRegionMutex.Lock()
        defer fake.getRegionMutex.Unlock()
        fake.GetRegionStub = stub
}</span>

func (fake *FakeNodeMetadata) GetRegionReturns(result1 string) <span class="cov10" title="3">{
        fake.getRegionMutex.Lock()
        defer fake.getRegionMutex.Unlock()
        fake.GetRegionStub = nil
        fake.getRegionReturns = struct {
                result1 string
        }{result1}
}</span>

func (fake *FakeNodeMetadata) GetRegionReturnsOnCall(i int, result1 string) <span class="cov0" title="0">{
        fake.getRegionMutex.Lock()
        defer fake.getRegionMutex.Unlock()
        fake.GetRegionStub = nil
        if fake.getRegionReturnsOnCall == nil </span><span class="cov0" title="0">{
                fake.getRegionReturnsOnCall = make(map[int]struct {
                        result1 string
                })
        }</span>
        <span class="cov0" title="0">fake.getRegionReturnsOnCall[i] = struct {
                result1 string
        }{result1}</span>
}

func (fake *FakeNodeMetadata) GetWorkerID() string <span class="cov1" title="1">{
        fake.getWorkerIDMutex.Lock()
        ret, specificReturn := fake.getWorkerIDReturnsOnCall[len(fake.getWorkerIDArgsForCall)]
        fake.getWorkerIDArgsForCall = append(fake.getWorkerIDArgsForCall, struct {
        }{})
        fake.recordInvocation("GetWorkerID", []interface{}{})
        fake.getWorkerIDMutex.Unlock()
        if fake.GetWorkerIDStub != nil </span><span class="cov0" title="0">{
                return fake.GetWorkerIDStub()
        }</span>
        <span class="cov1" title="1">if specificReturn </span><span class="cov0" title="0">{
                return ret.result1
        }</span>
        <span class="cov1" title="1">fakeReturns := fake.getWorkerIDReturns
        return fakeReturns.result1</span>
}

func (fake *FakeNodeMetadata) GetWorkerIDCallCount() int <span class="cov0" title="0">{
        fake.getWorkerIDMutex.RLock()
        defer fake.getWorkerIDMutex.RUnlock()
        return len(fake.getWorkerIDArgsForCall)
}</span>

func (fake *FakeNodeMetadata) GetWorkerIDCalls(stub func() string) <span class="cov0" title="0">{
        fake.getWorkerIDMutex.Lock()
        defer fake.getWorkerIDMutex.Unlock()
        fake.GetWorkerIDStub = stub
}</span>

func (fake *FakeNodeMetadata) GetWorkerIDReturns(result1 string) <span class="cov10" title="3">{
        fake.getWorkerIDMutex.Lock()
        defer fake.getWorkerIDMutex.Unlock()
        fake.GetWorkerIDStub = nil
        fake.getWorkerIDReturns = struct {
                result1 string
        }{result1}
}</span>

func (fake *FakeNodeMetadata) GetWorkerIDReturnsOnCall(i int, result1 string) <span class="cov0" title="0">{
        fake.getWorkerIDMutex.Lock()
        defer fake.getWorkerIDMutex.Unlock()
        fake.GetWorkerIDStub = nil
        if fake.getWorkerIDReturnsOnCall == nil </span><span class="cov0" title="0">{
                fake.getWorkerIDReturnsOnCall = make(map[int]struct {
                        result1 string
                })
        }</span>
        <span class="cov0" title="0">fake.getWorkerIDReturnsOnCall[i] = struct {
                result1 string
        }{result1}</span>
}

func (fake *FakeNodeMetadata) GetZone() string <span class="cov1" title="1">{
        fake.getZoneMutex.Lock()
        ret, specificReturn := fake.getZoneReturnsOnCall[len(fake.getZoneArgsForCall)]
        fake.getZoneArgsForCall = append(fake.getZoneArgsForCall, struct {
        }{})
        fake.recordInvocation("GetZone", []interface{}{})
        fake.getZoneMutex.Unlock()
        if fake.GetZoneStub != nil </span><span class="cov0" title="0">{
                return fake.GetZoneStub()
        }</span>
        <span class="cov1" title="1">if specificReturn </span><span class="cov0" title="0">{
                return ret.result1
        }</span>
        <span class="cov1" title="1">fakeReturns := fake.getZoneReturns
        return fakeReturns.result1</span>
}

func (fake *FakeNodeMetadata) GetZoneCallCount() int <span class="cov0" title="0">{
        fake.getZoneMutex.RLock()
        defer fake.getZoneMutex.RUnlock()
        return len(fake.getZoneArgsForCall)
}</span>

func (fake *FakeNodeMetadata) GetZoneCalls(stub func() string) <span class="cov0" title="0">{
        fake.getZoneMutex.Lock()
        defer fake.getZoneMutex.Unlock()
        fake.GetZoneStub = stub
}</span>

func (fake *FakeNodeMetadata) GetZoneReturns(result1 string) <span class="cov10" title="3">{
        fake.getZoneMutex.Lock()
        defer fake.getZoneMutex.Unlock()
        fake.GetZoneStub = nil
        fake.getZoneReturns = struct {
                result1 string
        }{result1}
}</span>

func (fake *FakeNodeMetadata) GetZoneReturnsOnCall(i int, result1 string) <span class="cov0" title="0">{
        fake.getZoneMutex.Lock()
        defer fake.getZoneMutex.Unlock()
        fake.GetZoneStub = nil
        if fake.getZoneReturnsOnCall == nil </span><span class="cov0" title="0">{
                fake.getZoneReturnsOnCall = make(map[int]struct {
                        result1 string
                })
        }</span>
        <span class="cov0" title="0">fake.getZoneReturnsOnCall[i] = struct {
                result1 string
        }{result1}</span>
}

func (fake *FakeNodeMetadata) Invocations() map[string][][]interface{} <span class="cov0" title="0">{
        fake.invocationsMutex.RLock()
        defer fake.invocationsMutex.RUnlock()
        fake.getRegionMutex.RLock()
        defer fake.getRegionMutex.RUnlock()
        fake.getWorkerIDMutex.RLock()
        defer fake.getWorkerIDMutex.RUnlock()
        fake.getZoneMutex.RLock()
        defer fake.getZoneMutex.RUnlock()
        copiedInvocations := map[string][][]interface{}{}
        for key, value := range fake.invocations </span><span class="cov0" title="0">{
                copiedInvocations[key] = value
        }</span>
        <span class="cov0" title="0">return copiedInvocations</span>
}

func (fake *FakeNodeMetadata) recordInvocation(key string, args []interface{}) <span class="cov10" title="3">{
        fake.invocationsMutex.Lock()
        defer fake.invocationsMutex.Unlock()
        if fake.invocations == nil </span><span class="cov10" title="3">{
                fake.invocations = map[string][][]interface{}{}
        }</span>
        <span class="cov10" title="3">if fake.invocations[key] == nil </span><span class="cov10" title="3">{
                fake.invocations[key] = [][]interface{}{}
        }</span>
        <span class="cov10" title="3">fake.invocations[key] = append(fake.invocations[key], args)</span>
}

var _ NodeMetadata = new(FakeNodeMetadata)
</pre>
		
		<pre class="file" id="file5" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Bluemix Container Registry, 5737-D42
 * (C) Copyright IBM Corp. 2020 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets,  * irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package metadata

import (
        "fmt"
        "github.com/IBM/ibm-csi-common/pkg/utils"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
)

// NodeMetadata is a fakeable interface exposing necessary data
type NodeMetadata interface {
        // GetZone ...
        GetZone() string

        // GetRegion ...
        GetRegion() string

        // GetWorkerID ...
        GetWorkerID() string
}

type nodeMetadataManager struct {
        zone     string
        region   string
        workerID string
}

var _ NodeMetadata = &amp;nodeMetadataManager{}

// NewNodeMetadata ...
func NewNodeMetadata(nodeName string, logger *zap.Logger) (NodeMetadata, error) <span class="cov8" title="1">{
        config, err := rest.InClusterConfig()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // creates the clientset
        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">node, err := clientset.CoreV1().Nodes().Get(nodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeLabels := node.ObjectMeta.Labels
        if len(nodeLabels[utils.NodeWorkerIDLabel]) == 0 || len(nodeLabels[utils.NodeRegionLabel]) == 0 || len(nodeLabels[utils.NodeZoneLabel]) == 0 </span><span class="cov0" title="0">{
                errorMsg := fmt.Errorf("One or few required node label(s) is/are missing [%s, %s, %s]. Node Labels Found = [#%v]", utils.NodeWorkerIDLabel, utils.NodeRegionLabel, utils.NodeZoneLabel, nodeLabels)
                return nil, errorMsg
        }</span>

        <span class="cov0" title="0">return &amp;nodeMetadataManager{
                zone:     nodeLabels[utils.NodeZoneLabel],
                region:   nodeLabels[utils.NodeRegionLabel],
                workerID: nodeLabels[utils.NodeWorkerIDLabel],
        }, nil</span>
}

func (manager *nodeMetadataManager) GetZone() string <span class="cov8" title="1">{
        return manager.zone
}</span>

func (manager *nodeMetadataManager) GetRegion() string <span class="cov8" title="1">{
        return manager.region
}</span>

func (manager *nodeMetadataManager) GetWorkerID() string <span class="cov8" title="1">{
        return manager.workerID
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Kubernetes Service, 5737-D43
 * (C) Copyright IBM Corp. 2019 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package metrics

import (
        "go.uber.org/zap"
        "time"

        "github.com/prometheus/client_golang/prometheus"
)

// FunctionLabel is a name of CSI plugin operation for which
// we measure duration
type FunctionLabel string

var pluginNamespace string

var (
        /**** Metrics related to controller ****/
        volumesCount = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Namespace: pluginNamespace,
                        Name:      "volumes_count",
                        Help:      "Total Number of volumes in the cluster.",
                },
        )

        volumesAttachedCount = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Namespace: pluginNamespace,
                        Name:      "volumes_attached_count",
                        Help:      "Total Number of volumes attached in the cluster ",
                },
        )
        functionDuration = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Namespace: pluginNamespace,
                        Name:      "function_duration_seconds",
                        Help:      "Time taken by various operation of Plugin",
                }, []string{"function"},
        )
        functionCount = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: pluginNamespace,
                        Name:      "functions_total",
                        Help:      "The number of plugin operation  completeted successfully.",
                }, []string{"function"},
        )

        errorsCount = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: pluginNamespace,
                        Name:      "errors_total",
                        Help:      "The number of plugin operation  failed due to an error.",
                }, []string{"type"},
        )
)

// RegisterAll registers all metrics.
func RegisterAll(namespace string) <span class="cov1" title="1">{
        pluginNamespace = namespace
        prometheus.MustRegister(volumesCount)
        prometheus.MustRegister(volumesAttachedCount)
        prometheus.MustRegister(functionDuration)
        prometheus.MustRegister(functionCount)
        prometheus.MustRegister(errorsCount)
}</span>

// UpdateVolumeCount records number of volumes currently present in the cluster
func UpdateVolumeCount(podsCount int) <span class="cov1" title="1">{
        volumesCount.Set(float64(podsCount))
}</span>

// UpdateVolumeAttachedCount records number of volumes currently attached in the cluster
func UpdateVolumeAttachedCount(podsCount int) <span class="cov1" title="1">{
        volumesAttachedCount.Set(float64(podsCount))
}</span>

// UpdateDurationFromStart records the duration of the step identified by the
// label using start time
func UpdateDurationFromStart(logger *zap.Logger, label FunctionLabel, start time.Time) <span class="cov1" title="1">{
        duration := time.Now().Sub(start)
        logger.Info("Time to complete", zap.Float64(string(label), duration.Seconds()))
        UpdateDuration(label, duration)
}</span>

// UpdateDuration records the duration of the step identified by the label
func UpdateDuration(label FunctionLabel, duration time.Duration) <span class="cov10" title="2">{
        functionDuration.WithLabelValues(string(label)).Set(duration.Seconds())
}</span>

// RegisterError records any errors for any plugin operation.
func RegisterError(errType string, err error) <span class="cov1" title="1">{
        if err != nil </span><span class="cov1" title="1">{
                errType = err.Error() // TODO Get the error code
        }</span>
        <span class="cov1" title="1">errorsCount.WithLabelValues(errType).Add(1.0)</span>
}

// RegisterFunction records any errors for any plugin operation.
func RegisterFunction(label FunctionLabel) <span class="cov1" title="1">{
        functionCount.WithLabelValues(string(label)).Add(1.0)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2018 The Kubernetes Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mountmanager

import (
        "k8s.io/kubernetes/pkg/util/mount"
)

// NewFakeSafeMounter ...
func NewFakeSafeMounter() *mount.SafeFormatAndMount <span class="cov8" title="1">{
        execCallback := func(cmd string, args ...string) ([]byte, error) </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">fakeMounter := &amp;mount.FakeMounter{MountPoints: []mount.MountPoint{{
                Device: "valid-devicePath",
                Path:   "valid-vol-path",
                Type:   "ext4",
                Opts:   []string{"defaults"},
                Freq:   1,
                Pass:   2,
        }}, Log: []mount.FakeAction{}}
        fakeExec := mount.NewFakeExec(execCallback)
        return &amp;mount.SafeFormatAndMount{
                Interface: fakeMounter,
                Exec:      fakeExec,
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2018 The Kubernetes Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mountmanager

import (
        "k8s.io/kubernetes/pkg/util/mount"
)

// NewSafeMounter ...
func NewSafeMounter() *mount.SafeFormatAndMount <span class="cov8" title="1">{
        realMounter := mount.New("")
        realExec := mount.NewOsExec()
        return &amp;mount.SafeFormatAndMount{
                Interface: realMounter,
                Exec:      realExec,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Bluemix Container Registry, 5737-D42
 * (C) Copyright IBM Corp. 2020 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets,  * irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package utils

import (
        "encoding/json"
        "github.com/IBM/ibmcloud-volume-interface/config"
        "go.uber.org/zap"
        "io/ioutil"
        "path/filepath"
)

//ClusterInfo contians the cluster information
type ClusterInfo struct {
        ClusterID   string `json:"cluster_id"`
        ClusterName string `json:"cluster_name,omitempty"`
        DataCenter  string `json:"datacenter,omitempty"`
        CustomerID  string `json:"customer_id,omitempty"`
}

//NewClusterInfo loads cluster info
func NewClusterInfo(logger *zap.Logger) (*ClusterInfo, error) <span class="cov0" title="0">{
        configBasePath := config.GetConfPathDir()
        clusterInfo := &amp;ClusterInfo{}
        clusterInfoFile := filepath.Join(configBasePath, ClusterInfoPath)
        clusterInfoContent, err := ioutil.ReadFile(filepath.Clean(clusterInfoFile))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error while reading  cluster-config.json", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal([]byte(clusterInfoContent), clusterInfo)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error while parsing cluster-config", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return clusterInfo, nil</span>

}

//APIKey Decryptor contract
type APIKey interface {
        GetAPIKey(cipherText string) (string, error)
}

// APIKeyImpl implementation
type APIKeyImpl struct {
        logger *zap.Logger
}

//NewAPIKey returns the new decryptor
func NewAPIKey(loggerIn *zap.Logger) (*APIKeyImpl, error) <span class="cov0" title="0">{
        var err error
        apiKeyImp := &amp;APIKeyImpl{
                logger: loggerIn,
        }
        return apiKeyImp, err
}</span>

// GetIAMKeys ...
func (d *APIKeyImpl) UpdateIAMKeys(config *config.Config) (error) <span class="cov0" title="0">{
  if true </span><span class="cov0" title="0">{ // IKS env
    if config.Bluemix.Encryption </span><span class="cov0" title="0">{
                    config.Bluemix.IamAPIKey = ""
          }</span>
          <span class="cov0" title="0">if config.VPC.Encryption </span><span class="cov0" title="0">{
                    if config.VPC.APIKey != "" </span><span class="cov0" title="0">{
                               config.VPC.APIKey = ""
                    }</span>
                    <span class="cov0" title="0">if config.VPC.G2APIKey != "" </span><span class="cov0" title="0">{
                               config.VPC.G2APIKey = ""
                    }</span>
          }
  }
  <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package utils

import (
        "flag"
        "sync"
)

// LockEnabled ...
var LockEnabled = flag.Bool("lock_enabled", true, "Enable or disable lock")

// LockStore ...
type LockStore struct {
        store map[string]*sync.Mutex
}

//lockstore mutex
var lockstoremux = sync.Mutex{}

func (s *LockStore) checkAndInitLockStore() <span class="cov10" title="6">{
        if s.store == nil </span><span class="cov1" title="1">{
                s.store = make(map[string]*sync.Mutex)
        }</span>
}

func (s *LockStore) getLock(name string) *sync.Mutex <span class="cov10" title="6">{

        lockstoremux.Lock()
        defer lockstoremux.Unlock()

        //check and init lock storage
        s.checkAndInitLockStore()

        //Get the lock Object
        if s.store[name] == nil </span><span class="cov4" title="2">{
                s.store[name] = &amp;sync.Mutex{}
        }</span>
        <span class="cov10" title="6">return s.store[name]</span>
}

// Lock ...
func (s *LockStore) Lock(name string) <span class="cov6" title="3">{
        if *LockEnabled </span><span class="cov6" title="3">{
                s.getLock(name).Lock()
        }</span>
}

// Unlock ...
func (s *LockStore) Unlock(name string) <span class="cov6" title="3">{
        if *LockEnabled </span><span class="cov6" title="3">{
                s.getLock(name).Unlock()
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package utils

import (
        uid "github.com/satori/go.uuid"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "golang.org/x/net/context"
        "os"
)

// GetContextLogger ...
func GetContextLogger(ctx context.Context, isDebug bool) (*zap.Logger, string) <span class="cov5" title="2">{
        return GetContextLoggerWithRequestID(ctx, isDebug, nil)
}</span>

// GetContextLoggerWithRequestID  adds existing requestID in the logger
// The Existing requestID might be comming from ControllerPublishVolume etc
func GetContextLoggerWithRequestID(ctx context.Context, isDebug bool, requestIDIn *string) (*zap.Logger, string) <span class="cov10" title="4">{
        consoleDebugging := zapcore.Lock(os.Stdout)
        consoleErrors := zapcore.Lock(os.Stderr)
        encoderConfig := zap.NewProductionEncoderConfig()
        encoderConfig.TimeKey = "ts"
        encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        traceLevel := zap.NewAtomicLevel()
        if isDebug </span><span class="cov8" title="3">{
                traceLevel.SetLevel(zap.DebugLevel)
        }</span> else<span class="cov1" title="1"> {
                traceLevel.SetLevel(zap.InfoLevel)
        }</span>

        <span class="cov10" title="4">core := zapcore.NewTee(
                zapcore.NewCore(zapcore.NewJSONEncoder(encoderConfig), consoleDebugging, zap.LevelEnablerFunc(func(lvl zapcore.Level) bool </span><span class="cov0" title="0">{
                        return (lvl &gt;= traceLevel.Level()) &amp;&amp; (lvl &lt; zapcore.ErrorLevel)
                }</span>)),
                zapcore.NewCore(zapcore.NewJSONEncoder(encoderConfig), consoleErrors, zap.LevelEnablerFunc(func(lvl zapcore.Level) bool <span class="cov0" title="0">{
                        return lvl &gt;= zapcore.ErrorLevel
                }</span>)),
        )
        <span class="cov10" title="4">logger := zap.New(core, zap.AddCaller())
        // generating a unique request ID so that logs can be filter
        if requestIDIn == nil </span><span class="cov8" title="3">{
                // Generate New RequestID if not provided
                requestID := uid.NewV4().String()
                requestIDIn = &amp;requestID
        }</span>
        <span class="cov10" title="4">logger = logger.With(zap.String("RequestID", *requestIDIn))
        return logger, *requestIDIn + " "</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package utils

import (
        "bytes"
        csi "github.com/container-storage-interface/spec/lib/go/csi"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "os"
        "strings"
        "testing"
)

// NewVolumeCapabilityAccessMode ...
func NewVolumeCapabilityAccessMode(mode csi.VolumeCapability_AccessMode_Mode) *csi.VolumeCapability_AccessMode <span class="cov1" title="1">{
        return &amp;csi.VolumeCapability_AccessMode{Mode: mode}
}</span>

// NewControllerServiceCapability ...
func NewControllerServiceCapability(cap csi.ControllerServiceCapability_RPC_Type) *csi.ControllerServiceCapability <span class="cov1" title="1">{
        return &amp;csi.ControllerServiceCapability{
                Type: &amp;csi.ControllerServiceCapability_Rpc{
                        Rpc: &amp;csi.ControllerServiceCapability_RPC{
                                Type: cap,
                        },
                },
        }
}</span>

// NewNodeServiceCapability ...
func NewNodeServiceCapability(cap csi.NodeServiceCapability_RPC_Type) *csi.NodeServiceCapability <span class="cov1" title="1">{
        return &amp;csi.NodeServiceCapability{
                Type: &amp;csi.NodeServiceCapability_Rpc{
                        Rpc: &amp;csi.NodeServiceCapability_RPC{
                                Type: cap,
                        },
                },
        }
}</span>

// RoundUpBytes rounds up the volume size in bytes upto multiplications of GiB
// in the unit of Bytes
func RoundUpBytes(volumeSizeBytes int64) int64 <span class="cov1" title="1">{
        return roundUpSize(volumeSizeBytes, GiB) * GiB
}</span>

// BytesToGiB converts Bytes to GiB
func BytesToGiB(volumeSizeBytes int64) int <span class="cov1" title="1">{
        return int(volumeSizeBytes / GiB)
}</span>

// Check division by zero and int overflow
func roundUpSize(volumeSizeBytes int64, allocationUnitBytes int64) int64 <span class="cov1" title="1">{
        return (volumeSizeBytes + allocationUnitBytes - 1) / allocationUnitBytes
}</span>

// ListContainsSubstr Checks if subStr is there in mainStr
func ListContainsSubstr(mainStr []string, subStr string) bool <span class="cov6" title="3">{
        if len(subStr) &lt; 1 </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov4" title="2">for _, str := range mainStr </span><span class="cov10" title="6">{
                if str == subStr </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}

func getEnv(key string) string <span class="cov1" title="1">{
        return os.Getenv(strings.ToUpper(key))
}</span>

// GetTestLogger ...
func GetTestLogger(t *testing.T) (logger *zap.Logger, teardown func()) <span class="cov0" title="0">{

        atom := zap.NewAtomicLevel()
        atom.SetLevel(zap.DebugLevel)

        encoderCfg := zap.NewProductionEncoderConfig()
        encoderCfg.TimeKey = "timestamp"
        encoderCfg.EncodeTime = zapcore.ISO8601TimeEncoder

        buf := &amp;bytes.Buffer{}

        logger = zap.New(
                zapcore.NewCore(
                        zapcore.NewJSONEncoder(encoderCfg),
                        zapcore.AddSync(buf),
                        atom,
                ),
                zap.AddCaller(),
        )

        teardown = func() </span><span class="cov0" title="0">{
                _ = logger.Sync()
                if t.Failed() </span><span class="cov0" title="0">{
                        t.Log(buf)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Cloud Container Service, 5737-D43
 * (C) Copyright IBM Corp. 2019 All Rights Reserved.
 * The source code for this program is not  published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with
 * the U.S. Copyright Office.
 ******************************************************************************/

package watcher

import (
        "flag"
        "github.com/golang/glog"
        "os"
        "strings"
        "time"

        "github.com/IBM/ibmcloud-volume-interface/config"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        cloudprovider "github.com/IBM/ibm-csi-common/pkg/ibmcloudprovider"
        "github.com/IBM/ibm-csi-common/pkg/utils"
        "go.uber.org/zap"
        "golang.org/x/net/context"
        "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/kubernetes/scheme"
        v1core "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/cache"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/record"
)

//PVWatcher to watch  pv creation and add taggs
type PVWatcher struct {
        logger          *zap.Logger
        kclient         kubernetes.Interface
        config          *config.Config
        provisionerName string
        recorder        record.EventRecorder
        cloudProvider   cloudprovider.CloudProviderInterface
}

const (
        //IbmCloudGtAPIEndpoint ...
        IbmCloudGtAPIEndpoint = "IBMCLOUD_GT_API_ENDPOINT"
        //ReclaimPolicyTag ...
        ReclaimPolicyTag = "reclaimpolicy:"
        //NameSpaceTag ...
        NameSpaceTag = "namespace:"
        //StorageClassTag ...
        StorageClassTag = "storageclass:"
        //PVCNameTag ...
        PVCNameTag = "pvc:"
        //PVNameTag ...
        PVNameTag = "pv:"
        //VolumeCRN ...
        VolumeCRN = "volumeCRN"
        //ProvisionerTag ...
        ProvisionerTag = "provisioner:"

        //VolumeStatus ...
        VolumeStatus = "status"
        //VolumeStatusCreated ...
        VolumeStatusCreated = "created"
        //VolumeStatusDeleted ...
        VolumeStatusDeleted = "deleted"
        //VolumeUpdateEventReason ...
        VolumeUpdateEventReason = "VolumeMetaDataSaved"
        //VolumeUpdateEventSuccess ...
        VolumeUpdateEventSuccess = "Success"
)

//VolumeTypeMap ...
var VolumeTypeMap = map[string]string{}

var master = flag.String(
        "master",
        "",
        "Master URL to build a client config from. Either this or kubeconfig needs to be set if the provisioner is being run out of cluster.",
)
var kubeconfig = flag.String(
        "kubeconfig",
        "",
        "Absolute path to the kubeconfig file. Either this or master needs to be set if the provisioner is being run out of cluster.",
)

// New creates the Watcher instance
func New(logger *zap.Logger, provisionerName string, volumeType string, cloudProvider cloudprovider.CloudProviderInterface) *PVWatcher <span class="cov0" title="0">{
        var restConfig *rest.Config
        var err error
        // Register provider
        VolumeTypeMap[provisionerName] = volumeType

        restConfig, err = clientcmd.BuildConfigFromFlags(*master, *kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to create config:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to create client:", zap.Error(err))
        }</span>
        <span class="cov0" title="0">iksPodName := os.Getenv("POD_NAME")

        broadcaster := record.NewBroadcaster()
        broadcaster.StartLogging(glog.Infof)
        eventInterface := clientset.CoreV1().Events("")
        broadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl{Interface: eventInterface})
        pvw := &amp;PVWatcher{
                logger:          logger,
                config:          cloudProvider.GetConfig(),
                provisionerName: provisionerName,
                kclient:         clientset,
                cloudProvider:   cloudProvider,
                recorder:        broadcaster.NewRecorder(scheme.Scheme, v1.EventSource{Component: iksPodName}),
        }
        return pvw</span>

}

//Start start pv watcher
func (pvw *PVWatcher) Start() <span class="cov0" title="0">{
        watchlist := cache.NewListWatchFromClient(pvw.kclient.CoreV1().RESTClient(), "persistentvolumes", "", fields.Everything())
        _, controller := cache.NewInformer(watchlist, &amp;v1.PersistentVolume{}, time.Second*0,
                cache.FilteringResourceEventHandler{
                        Handler: cache.ResourceEventHandlerFuncs{
                                UpdateFunc: pvw.updateVolume,
                        },
                        FilterFunc: pvw.filter,
                },
        )
        pvw.logger.Info("PVWatcher starting")
        stopch := wait.NeverStop
        go controller.Run(stopch)
        pvw.logger.Info("PVWatcher started")
        &lt;-stopch
}</span>

func (pvw *PVWatcher) updateVolume(oldobj, obj interface{}) <span class="cov5" title="2">{
        // Run as non-blocking thread to allow parallel proccessing of volumes
        go func() </span><span class="cov5" title="2">{
                ctxLogger, requestID := utils.GetContextLogger(context.Background(), false)
                // panic-recovery function that avoid watcher thread to stop because of unexexpected error
                defer func() </span><span class="cov5" title="2">{
                        if r := recover(); r != nil </span><span class="cov5" title="2">{
                                ctxLogger.Error("Recovered from panic in pvwatcher", zap.Stack("stack"), zap.String("requestID", requestID))
                        }</span>
                }()

                <span class="cov5" title="2">ctxLogger.Info("Entry updateVolume()", zap.Reflect("obj", obj))
                pv, _ := obj.(*v1.PersistentVolume)
                session, err := pvw.cloudProvider.GetProviderSession(context.Background(), ctxLogger)
                if session != nil </span><span class="cov0" title="0">{
                        volume := pvw.getVolume(pv, ctxLogger)
                        ctxLogger.Info("volume to update ", zap.Reflect("volume", volume))
                        err := session.UpdateVolume(volume)
                        if err != nil </span><span class="cov0" title="0">{
                                ctxLogger.Warn("Unable to update the volume", zap.Error(err))
                                pvw.recorder.Event(pv, v1.EventTypeWarning, VolumeUpdateEventReason, err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                pvw.recorder.Event(pv, v1.EventTypeNormal, VolumeUpdateEventReason, VolumeUpdateEventSuccess)
                                ctxLogger.Warn("Volume Metadata saved successfully")
                        }</span>
                }
                <span class="cov0" title="0">ctxLogger.Info("Exit updateVolume()", zap.Error(err))</span>
        }()
}

func (pvw *PVWatcher) getTags(pv *v1.PersistentVolume, ctxLogger *zap.Logger) (string, []string) <span class="cov10" title="4">{
        ctxLogger.Debug("Entry getTags()", zap.Reflect("pv", pv))
        volAttributes := pv.Spec.CSI.VolumeAttributes
        // Get user tag list
        tagstr := strings.TrimSpace(volAttributes["tags"])
        var tags []string
        if len(tagstr) &gt; 0 </span><span class="cov8" title="3">{
                tags = strings.Split(tagstr, ",")
        }</span>
        // append default tags to users tag list
        <span class="cov10" title="4">tags = append(tags, utils.ClusterIDLabel+":"+volAttributes[utils.ClusterIDLabel])
        tags = append(tags, ReclaimPolicyTag+string(pv.Spec.PersistentVolumeReclaimPolicy))
        tags = append(tags, StorageClassTag+string(pv.Spec.StorageClassName))
        tags = append(tags, NameSpaceTag+string(pv.Spec.ClaimRef.Namespace))
        tags = append(tags, PVCNameTag+string(pv.Spec.ClaimRef.Name))
        tags = append(tags, PVNameTag+pv.ObjectMeta.Name)
        tags = append(tags, ProvisionerTag+pvw.provisionerName)
        ctxLogger.Debug("Exit getTags()", zap.String("VolumeCRN", volAttributes[VolumeCRN]), zap.Reflect("tags", tags))
        return volAttributes[VolumeCRN], tags</span>

}

func (pvw *PVWatcher) getVolume(pv *v1.PersistentVolume, ctxLogger *zap.Logger) provider.Volume <span class="cov5" title="2">{
        ctxLogger.Debug("Entry getVolume()", zap.Reflect("pv", pv))
        crn, tags := pvw.getTags(pv, ctxLogger)
        volume := provider.Volume{
                VolumeID:   pv.Spec.CSI.VolumeHandle,
                Provider:   provider.VolumeProvider(pvw.config.VPC.VPCBlockProviderType),
                VolumeType: provider.VolumeType(VolumeTypeMap[pv.Spec.CSI.Driver]),
        }
        volume.CRN = crn
        clusterID := pv.Spec.CSI.VolumeAttributes[utils.ClusterIDLabel]
        volume.Attributes = map[string]string{strings.ToLower(utils.ClusterIDLabel): clusterID}
        if pv.Status.Phase == v1.VolumeReleased </span><span class="cov0" title="0">{
                // Set only status in case of delete operation
                volume.Attributes[VolumeStatus] = VolumeStatusDeleted
        }</span> else<span class="cov5" title="2"> {
                volume.Tags = tags
                //Get Capacity and convert to GiB
                capacity := pv.Spec.Capacity[v1.ResourceStorage]
                capacityGiB := utils.BytesToGiB(capacity.Value())
                volume.Capacity = &amp;capacityGiB
                iops := pv.Spec.CSI.VolumeAttributes[utils.IOPSLabel]
                volume.Iops = &amp;iops
                volume.Attributes[VolumeStatus] = VolumeStatusCreated
        }</span>
        <span class="cov5" title="2">ctxLogger.Debug("Exit getVolume()", zap.Reflect("volume", volume))
        return volume</span>
}

func (pvw *PVWatcher) filter(obj interface{}) bool <span class="cov0" title="0">{
        pvw.logger.Debug("Entry filter()", zap.Reflect("obj", obj))
        pv, _ := obj.(*v1.PersistentVolume)
        provisoinerMatch := pv.Spec.CSI.Driver == pvw.provisionerName
        pvw.logger.Debug("Exit filter()", zap.Bool("provisoinerMatch", provisoinerMatch))
        return provisoinerMatch
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
